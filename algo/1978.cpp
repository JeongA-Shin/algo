#include <iostream>
using namespace std;

//소수의 판별
//1. 맨땅에 헤딩(판별해야할 게 얼마 없을 때)
//    : 임의의 수 n이 있을 때, 2부터 n-1부까지 모두 나누어 나머지가 0인 경우가 있는지 판별. 이 때 하나라도 나머지가 0인 경우가 나오면 소수가 아님
//2. 에라토스테네스의 체(판별해야 하는 수가 대량일 때) == dp임: 
//   위의 계산을 줄인다면, n의 제곱근까지만 연산해도 됨 (즉 2부터 루트 n까지만 나누어 판별) - 이미 증명된 공식임
//   반대로 2부터 n의 제곱근까지 돌며 해당 수의 모든 배수들을 소수에서 제외
//   - 이게 무슨 말이냐면, 우선 배열에서 2를 제외한 2의 배수들을 지움 : 지워지는 건 소수가 아님
//                                    3을 제외한 3의 배수들을 지움 : 지워지는 건 소수가 아님
// ... 위의 과정을 반복하면 결국 남는 건 소수밖에 없음


//예를 들어 1부터 25까지의 수 중 소수만 구해보자고 생각
/*
* 01 02 03 04 05
* 06 07 08 09 10
* 11 12 13 14 15
* 16 17 18 19 20
* 21 22 23 24 25
*/

//위의 표에서 2의 배수를 지워봄 (자기 자신은 지우지 않음)
/*
* 01 02 03    05
*    07    09   
* 11    13    15
*    17    19 
* 21    23    25
*/

//이제 3의 배수를 지움(자기 자신은 지우지 않음) - 이미 지워진 숫자면 건너뜀
/*
* 01 02       05
*    07      
* 11    13    
*    17    19
*       23    25
*/

//이제 4의 배수를 지워야 하는데 이미 2의 배수이므로 지워짐. 그러면 건너뜀. (없는 셈 침)

//이렇게 위의 과정을 반복하면 결국 기존의 표에서 남는 수는
//2 3 5 7 11 13 17 19 23 이렇게 남게 됨

//이게 에라토스테네스의 체임

//int num[101] = { 1, };//디폴트는 1, 지워지면 0
/*
* 다른 값으로 초기화 하려면

int array[10] = {5,}; 

가 될까 싶었는데, 결론적으론 안된다. (첫 원소값만 5가 되고 나머지는 0으로 초기화 된다)
*/

int num[1001];

int main() {

	for (int i = 1; i < 1001; i++) {

		num[i] = 1;
	}

	

	//dp. 에라토스테네스의 체 활용
	//미리 체에 소수만 남겨두기 (미리 체에 걸러서 남겨두기)
	for (int i = 2; i < 1001; i++) {
		if (num[i] == 0) {
			continue; //만약 이미 (시작점부터) 지워진 숫자면 해당 수의 배수는 건너뜀
			//ex. - 이제 4의 배수를 지워야 하는데 시작점 4부터 이미 2의 배수이므로 지워짐. 그러면 건너뜀. (없는 셈 침)
		}
		else {
			//차례대로 해당 수의 배수들(i+i)을 지워줌
			for (int j = i + i; j <1001; j+=i) {
				num[j] = 0;
			}
		}

	}

	/* 체에 걸러진 결과 확인 - 소수 판정 확인
	for (int i = 2; i < 1001; i++) { //1은 소수 판별에서 제외함
		if (num[i] != 0) {
			cout << i << " ";
		}

	}
	*/

	//그리고 주어진 수가 해당 체에 남아 있으면 소수인 거임

	int n;
	cin >> n;

	int cnt = 0;

	for (int i = 0; i < n; i++) { //입력받기
		int m;
		cin >> m;

		if (m!=1 && num[m] != 0) {
			cnt++;
		}
		
	}

	cout << cnt << endl;

}