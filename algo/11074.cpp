#include <iostream>
using namespace std;

// 그리디 알고리즘 : 매 선택에서 지금 이 순간 당장 최적인 답
// 1. 앞의 선택이 이후의 선택에 영향을 주지 않는다
//2. 문제에 대한 최적해가 부분문제에 대해서도 역시 최적해

/*
* dp는 재귀적으로 배열에 저장하는 방식이기에 브루트포스에 해당하고 
  그리디는 재귀적으로 찾아가는 방식에서 답이 아닌 경우를 알게 되면 과감하게 경로를 포기하는 알고리즘
*/

/*
*  greedy : 다양한 선택 중 가장 좋은 전략 몇가지만 시도해보는 방법입니다. 이렇게 한다면 보통 완전 탐색보다 쉽고 빠르게 동작하겠죠. 이렇게 해서 문제를 풀면 틀리기도 하지만, 증명을 해서 맞는 그리디 알고리즘을 만들 수도 있습니다.

* exhaustive search (완전 탐색) : 모든 선택을 열거하는 방법입니다. 열거를 하면 그중 좋은 전략을 찾는 것은 쉽겠죠. 

* dp : 일반적으로, 메모리 공간을 써서 중복 계산을 줄이는 모든 방법을 통칭합니다. 완전 탐색의 "메모이제이션"이 주요한 응용 예입니다. 



dp가 완전 탐색이랑 자주 엮이기 때문에, dp와 그리디를 "정반대 방법" 이라고 여기는 사람들도 있습니다. 

동적계획법과는 약간의 다른 느낌이 심어진다는 것을 알 수 있다.
동적계획법은 각각의 상황을 모두 고려하여 "전체" 최적의 조건을 위해 '점화식'을 세워 연산하고 비교하기 때문이다.
그리디는 부분 문제에 대해 최적인 해가 결국 전체의 해가 되는 것임. (dp는 부분문제에서는 최적이어도 전체에서 최적이 아니면 고려 안 함)

*/



/*
* 이 문제에서는 탐욕적으로 제일 큰 값이 되는 것부터 채우고, 그 다음에 작은 애들을 채워줌
* -> 전체 경우에서 생각하지 않고 일단 큰 거부터 채워버림
*/

int arr[11];

int main() {

	int n, k;
	cin >> n >> k; //동전의 총 종류, 만들고자 하는 가치의 합

	int cnt = 0; //전체 답

	for (int i = 0; i < n; i++) {
		int coin;
		cin >> coin; //문제 조건에서 오름차순으로 주어진다고 함
		arr[i] = coin;
	}

	for (int i = n-1; i >= 0; i--) { //제일 큰 수부터 
		//cout << "arr[i]: " << arr[i] << endl;

		if (arr[i] > k) {
			continue; //만약 입력된 값이 더 크면 바로 패스
		}

		int curr = k / arr[i];//해당 동전이 몇 개가 필요한지
		//cout << " k / arr[i]: " << k / arr[i] << endl;

		cnt += curr; // 전체 개수에 더해주기
		//cout << "updated cnt: " << cnt << endl;

		k -= arr[i] * curr; //남은 값으로 업데이트
		//cout << "updated value: " << k << endl;
		
	}

	cout << cnt << endl;

}